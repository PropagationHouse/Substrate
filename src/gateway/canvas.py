"""
Canvas Surfaces - Rich WebView UI for Agent Interactions
=========================================================

Canvas that allows the agent to generate and display
rich interactive content (HTML, charts, forms, dashboards).

Features:
- HTTP file server for generated content
- Agent can create HTML/JS/CSS files
- WebView integration for Electron
- Live updating content
"""

import os
import json
import time
import logging
import threading
from pathlib import Path
from typing import Dict, Any, Optional, List
from dataclasses import dataclass, asdict
from http.server import HTTPServer, SimpleHTTPRequestHandler
import urllib.parse

logger = logging.getLogger("gateway.canvas")

# Soma (project root)
SOMA = Path(__file__).parent.parent.parent
DATA_DIR = SOMA / "data"
CANVAS_DIR = DATA_DIR / "canvas"

# Default port for canvas server
DEFAULT_CANVAS_PORT = 18793


@dataclass
class CanvasPage:
    """A canvas page/surface."""
    id: str
    title: str
    content: str  # HTML content
    created_at: float
    updated_at: float
    content_type: str = "text/html"
    metadata: Dict[str, Any] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


class CanvasHandler(SimpleHTTPRequestHandler):
    """HTTP handler for canvas content."""
    
    def __init__(self, *args, canvas_dir: Path = None, **kwargs):
        self.canvas_dir = canvas_dir or CANVAS_DIR
        super().__init__(*args, directory=str(self.canvas_dir), **kwargs)
    
    def log_message(self, format, *args):
        logger.debug(f"Canvas: {format % args}")
    
    def do_GET(self):
        """Handle GET requests."""
        # Parse path
        parsed = urllib.parse.urlparse(self.path)
        path = parsed.path.strip('/')
        
        if not path:
            # Serve index
            self.serve_index()
            return
        
        # Serve file from canvas directory
        super().do_GET()
    
    def serve_index(self):
        """Serve canvas index page."""
        pages = list_canvas_pages()
        
        html = """<!DOCTYPE html>
<html>
<head>
    <title>Substrate Canvas</title>
    <style>
        body { font-family: system-ui, sans-serif; padding: 20px; background: #1a1a2e; color: #eee; }
        h1 { color: #00d4ff; }
        .page { background: #16213e; padding: 15px; margin: 10px 0; border-radius: 8px; }
        .page a { color: #00d4ff; text-decoration: none; font-size: 1.2em; }
        .page a:hover { text-decoration: underline; }
        .meta { color: #888; font-size: 0.9em; margin-top: 5px; }
    </style>
</head>
<body>
    <h1>Substrate Canvas</h1>
    <p>Rich content surfaces generated by the agent.</p>
"""
        
        if pages:
            for page in pages:
                html += f"""
    <div class="page">
        <a href="/{page['id']}.html">{page['title']}</a>
        <div class="meta">Updated: {page['updated_at']}</div>
    </div>
"""
        else:
            html += "<p>No canvas pages yet. The agent can create them!</p>"
        
        html += """
</body>
</html>
"""
        
        self.send_response(200)
        self.send_header('Content-Type', 'text/html')
        self.send_header('Content-Length', len(html.encode()))
        self.end_headers()
        self.wfile.write(html.encode())


def ensure_canvas_dir():
    """Ensure canvas directory exists."""
    CANVAS_DIR.mkdir(parents=True, exist_ok=True)


def create_canvas_page(
    page_id: str,
    title: str,
    content: str,
    content_type: str = "text/html",
    metadata: Optional[Dict[str, Any]] = None,
) -> str:
    """
    Create or update a canvas page.
    
    Args:
        page_id: Unique page identifier
        title: Page title
        content: HTML/JS/CSS content
        content_type: MIME type
        metadata: Optional metadata
    
    Returns:
        URL to access the page
    """
    ensure_canvas_dir()
    
    now = time.time()
    
    # Determine file extension
    ext = ".html"
    if "javascript" in content_type:
        ext = ".js"
    elif "css" in content_type:
        ext = ".css"
    elif "json" in content_type:
        ext = ".json"
    
    # Write content file
    filepath = CANVAS_DIR / f"{page_id}{ext}"
    with open(filepath, 'w', encoding='utf-8') as f:
        f.write(content)
    
    # Write metadata
    meta_path = CANVAS_DIR / f"{page_id}.meta.json"
    meta = {
        'id': page_id,
        'title': title,
        'content_type': content_type,
        'created_at': now,
        'updated_at': now,
        'metadata': metadata or {},
    }
    
    # Preserve created_at if updating
    if meta_path.exists():
        try:
            with open(meta_path, 'r') as f:
                old_meta = json.load(f)
            meta['created_at'] = old_meta.get('created_at', now)
        except Exception:
            pass
    
    with open(meta_path, 'w') as f:
        json.dump(meta, f, indent=2)
    
    logger.info(f"Created canvas page: {page_id}")
    
    return f"http://localhost:{DEFAULT_CANVAS_PORT}/{page_id}{ext}"


def get_canvas_page(page_id: str) -> Optional[Dict[str, Any]]:
    """Get a canvas page by ID."""
    meta_path = CANVAS_DIR / f"{page_id}.meta.json"
    
    if not meta_path.exists():
        return None
    
    try:
        with open(meta_path, 'r') as f:
            meta = json.load(f)
        
        # Find content file
        for ext in ['.html', '.js', '.css', '.json']:
            content_path = CANVAS_DIR / f"{page_id}{ext}"
            if content_path.exists():
                with open(content_path, 'r', encoding='utf-8') as f:
                    meta['content'] = f.read()
                break
        
        return meta
        
    except Exception as e:
        logger.error(f"Failed to get canvas page: {e}")
        return None


def list_canvas_pages(limit: int = 20) -> List[Dict[str, Any]]:
    """List all canvas pages."""
    ensure_canvas_dir()
    
    pages = []
    
    for meta_path in sorted(CANVAS_DIR.glob("*.meta.json"), reverse=True):
        if len(pages) >= limit:
            break
        
        try:
            with open(meta_path, 'r') as f:
                meta = json.load(f)
            
            from datetime import datetime
            meta['updated_at'] = datetime.fromtimestamp(
                meta.get('updated_at', 0)
            ).strftime('%Y-%m-%d %H:%M')
            
            pages.append(meta)
            
        except Exception:
            continue
    
    return pages


def delete_canvas_page(page_id: str) -> bool:
    """Delete a canvas page."""
    deleted = False
    
    for ext in ['.html', '.js', '.css', '.json', '.meta.json']:
        filepath = CANVAS_DIR / f"{page_id}{ext}"
        if filepath.exists():
            filepath.unlink()
            deleted = True
    
    if deleted:
        logger.info(f"Deleted canvas page: {page_id}")
    
    return deleted


# Canvas server management
_canvas_server: Optional[HTTPServer] = None
_canvas_thread: Optional[threading.Thread] = None


def start_canvas_server(port: int = DEFAULT_CANVAS_PORT) -> bool:
    """Start the canvas HTTP server."""
    global _canvas_server, _canvas_thread
    
    if _canvas_server is not None:
        logger.warning("Canvas server already running")
        return False
    
    ensure_canvas_dir()
    
    try:
        # Create handler with canvas directory
        handler = lambda *args, **kwargs: CanvasHandler(
            *args, canvas_dir=CANVAS_DIR, **kwargs
        )
        
        _canvas_server = HTTPServer(('127.0.0.1', port), handler)
        
        def serve():
            logger.info(f"Canvas server started on http://127.0.0.1:{port}")
            _canvas_server.serve_forever()
        
        _canvas_thread = threading.Thread(target=serve, daemon=True)
        _canvas_thread.start()
        
        return True
        
    except Exception as e:
        logger.error(f"Failed to start canvas server: {e}")
        _canvas_server = None
        return False


def stop_canvas_server():
    """Stop the canvas HTTP server."""
    global _canvas_server, _canvas_thread
    
    if _canvas_server is not None:
        _canvas_server.shutdown()
        _canvas_server = None
        _canvas_thread = None
        logger.info("Canvas server stopped")


def is_canvas_server_running() -> bool:
    """Check if canvas server is running."""
    return _canvas_server is not None


# Exports
__all__ = [
    "CanvasPage",
    "create_canvas_page",
    "get_canvas_page",
    "list_canvas_pages",
    "delete_canvas_page",
    "start_canvas_server",
    "stop_canvas_server",
    "is_canvas_server_running",
    "DEFAULT_CANVAS_PORT",
]
